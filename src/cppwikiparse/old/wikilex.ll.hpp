/* Interface and state class for WikiLex
   Uses some of the structures generated by flex, so *must* be included after flex structures are defined. */

#ifndef _WIKILEX_LL_HPP
#define _WIKILEX_LL_HPP

struct WikiLex {
	
	struct State {
		int buf_pos;
		int start_cond;
		bool pendeof;
		int pend_tok_type;
		const unsigned char * pend_tok_pos;
		int pend_tok_len;
		State(WikiLex & lexer) { lexer.getState(*this); }
		State(WikiLex * lexer) { lexer->getState(*this); }
		State() {}
	};

	WikiLex(const unsigned char *buf = NULL, int buflen = 0);
	~WikiLex();
	void setFullBuffer(const unsigned char *buf, int buflen);
	int getBufferPos();
	void resetBufferPos(int pos);
	void setCondition(int cond);
	int getCondition();
	int nextToken(const unsigned char ** textpos = NULL, int * textlen = NULL);
	int peekToken(const unsigned char ** textpos = NULL, int * textlen = NULL);
	int nextToken(const char ** textpos = NULL, int * textlen = NULL) {
		return nextToken((const unsigned char **)textpos, textlen);
	}
	int peekToken(const char ** textpos = NULL, int * textlen = NULL) {
		return peekToken((const unsigned char **)textpos, textlen);
	}

	void getState(State & st) {
		st.buf_pos = getBufferPos();
		st.start_cond = getCondition();
		st.pendeof = pending_eof;
		st.pend_tok_type = pending_token_type;
		st.pend_tok_pos = pending_token_pos;
		st.pend_tok_len = pending_token_len;
	}
	void restoreState(const State & st) {
		resetBufferPos(st.buf_pos);
		setCondition(st.start_cond);
		pending_eof = st.pendeof;
		pending_token_type = st.pend_tok_type;
		pending_token_pos = st.pend_tok_pos;
		pending_token_len = st.pend_tok_len;
	}

	enum { TEXT, END, CURLY_OPEN_SERIES, WHITESPACE, TEMPLATE_CLOSE, PIPE };

	int prefer_block_size;

	const unsigned char * fullbuf_start;
	int fullbuf_len;
	int fullbuf_pos;
	int fullbuf_read_pos;

	bool pending_eof;
	int pending_token_type;
	const unsigned char * pending_token_pos;
	int pending_token_len;

	yyscan_t scanner;
};

#endif

